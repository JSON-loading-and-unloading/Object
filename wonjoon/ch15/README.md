## 디자인 패턴이란

소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴이라고 부른다.

이에 대해 ‘하나의 실무 컨텍스트에서 유용하게 사용해 왔고, 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어’ 라고 정의하고 있다.

그리고 이에 대한 조건으로 ‘3의 규칙’을 언급하는데 세가지의 서로 다른 시스템에 특별한 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있다고 한다.

## 프레임워크란

설계와 코드를 함께 재사용하기 위한 것으로 프레임워크는 어플리케이션의 아키텍처를 코드의 형태로 제공한다.

프레임워크가 제공하는 아키텍처가 요구사항에 적합하다면 다양한 환경에서 테스트를 거친 견고한 구현 코드를 쉽고 빠르게 재사용할 수 있다.

## 디자인 패턴과 설계 재사용

패턴을 분류하는 방식이 있는데, 일반적으로 패턴의 범위나 적용 단계에 따라 구분한다.

- 아키텍처 패턴 : 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있는 것으로 디자인 패턴 상위이다.
- 디자인 패턴 : 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트 사이에서 반복적으로 발생하는 구조를 서술한다.
- 이디엄 : 특정 프로그래밍 언어에 국한된 하위 레벨 패턴으로 디자인 패턴 하위이다.
- 분류 패턴 : 도메인 내의 개념적인 문제를 해결하는데 초점을 맞춘 것으로 기술적 문제를 해결하는데 초점을 맞춘 위 3가지와 약간 다른 패턴이다.

### 패턴과 책임 주도 설계

여러가지 패턴이 있는데, 우리가 주목할 점은 어떠한 코드가 어떤 디자인 패턴을 따른다고 이야기 할때는 역할, 책임, 협력의 관점에서 유사성을 공유한다는 것이지 특정한 구현 방식을 강제하는 것이 아니라는 점을 이해하는 것이다.

디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다.

우리는 패턴을 적용하기 위해서 패턴에서 제시하는 구조를 그대로 표현하는 것이 아닌 패턴의 기본 구조로부터 출발해서 현재의 요구에 맞게 구조를 수정해야 한다는 것을 의미한다.

### 캡슐화와 디자인 패턴

디자인 패턴의 목적은 특정한 변경을 캡슐화 하여 유연하고 일관성 있는 협력을 설계할 수 있는 경험을 공유하는 것이다.

디자인 패턴에서 중요한 것은 디자인 패턴의 구현 방법이나 구조가 아닌, 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지 이해하는 것이다.

그리고 각 디자인 패턴이 변경을 캡슐화하기 위해 어떤 방법을 사용하는지 이해하는 것이 중요하다.

### 패턴은 출발점이다

망치를 들면 모든 것이 못으로 보인다는 것처럼 패턴을 익힌 후에는 모든 설계 문제를 패턴으로 해결하려 시도할 수 있다.

우리는 이를 주의해야 한다.

모든 문제에 대해서 패턴을 맹목적으로 사용해서는 안된다.

패턴을 가장 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링 하는 것이라고 한다.

패턴이 적용된 최종 결과를 이해하는 것보다는 패턴을 목표로 리팩터링하는 이유를 이해하는 것이 훨씬 가치있으며 훌륭한 소프트웨어 설계까 발전해 온 과정을 공부하는 것이 훌륭한 설계 자체를 공부하는 것보다 훨씬 중요하다고 한다.

패턴은 출발점이다. 패턴은 공통적인 문제에 적절한 해법을 제공하지만 공통적인 해법이 우리가 직면한 문제에 적합하지 않을 수 있다는 것을 주의하자.

### 코드 재사용과 설계 재사용

설계 재사용보다 더 좋은 방법은 코드 재사용이라고 한다.

오랜 시간동안 개발자들은 부품을 조립해서 제품을 만드는 것처럼 별도의 프로그래밍 없이 기존의 컴포턴트를 졸비해서 어플리케이션을 구축하는 방법을 추구해왔다.

하지만 이러한 컴포턴트 기반의 재사용 방법은 이상적이지만 실제로 적용하는 과정에서 현실적이지 않았다.

이러한 코드 재사용만을 강조하는 컴포넌트는 실패했다.

따라서 가장 이상적인 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다.

이때 프레임워크라는 개념을 이용하게 되는데, 프레임워크는 코드를 재사용함으로써 설계 아이디를 재사용한다. 프레임워크는 어플리케이션 아키텍처를 제공하며 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함한다.

또한 부분적으로 구현된 추상 클래스와 인터페이스 집합 뿐만 아니라 추가적인 작업 없이도 재사용할 수 있는 다양한 종류의 컴포넌트도 함께 제공한다.

### 상위 정책과 하위 정책으로 패키지 분리하기

프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화라고 할 수 있다.

이는 일관성 있는 협력이라는 주제와 관련이 있다.

객체지향 이전의 구조적인 설계와 같은 전통적인 소프트웨어 개발 방법의 경우 상위 레벨이 하위 레벨에 그리고 상위 정책이 구체적인 세부사항에 의존하도록 구성되어 있다.

하지만, 상위 정책은 상대적으로 변경에 안정적이지만, 세부 사항은 자주 변경된다.

그리고 상위 정책이 세부사항에 비해 재사용될 가능성이 높다.

요점은 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용될 수 있어야 한다는 것이다.

의존성 역전의 원칙에서 세부 사항은 ‘변경’을 의미한다.

우리는 변경하는 것과 변경하지 않는 것을 서로 분리하고 서로 다른 주기로 배포할 수 있도록 별도의 ‘배포 단위’로 분리해야 한다.

이를 위해서는 변하는 부분과 변하지 않는 부분들을 별도의 패키지로 분리하는 것이 첫걸음이다.

이렇게 상위 정책을 구현하고 있는 패키지가 세부 사항을 구현한 패키지로 부터 완벽하게 분리가 되었다면 상위 정책을 구현하고 있는 패키지는 다른 어플리케이션에서도 재사용할 수 있는 것이고 이것이 컨텍스트 독립성의 패키지 버전이다.

그리고 이것이 프레임워크이다.

### 제어 역전 원리

객체지향 설계의 재사용성은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다.

그리고 그 뒤에는 항상 의존성 역전 원리나는 강력한 지원군이 존재하는데, 이는 전통적인 설계 방식과 객체지향을 구분하는 가장 핵심적인 원리이다.

이는 프레임워크의 가장 기본적인 설계 메커니즘으로 의존성의 방향 뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.

의존성을 연전시킨 객체지향 구조에서는 프레임워크가 어플리케이션에 속하는 서브 클래스의 메소드를 호출하는데, 이는 개별 어플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한 것이다.

우리는 협력을 제어하는 것은 프레임워크라는 것에 주목해야 한다.
