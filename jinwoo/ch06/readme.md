애플리케이션은 메시지를 통해 정의된다는 사실을 기억하라. 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다. 훌륭한 퍼블릭 인터페이스를 얻기 위해서는 설계 원칙과 기법을 익히고 적용해야 한다. 이번 장에서는 이러한 기법들을 살펴보는 것이 주제이다.

## 01 협력과 메시지

먼저 혼란스러운 용어부터 정리하자

### 메시지와 메시지 전송

- 메시지 : 객체들이 협력하기 위해 사용하는 유일한 의사소통 수단
    - 오퍼레이션명과 인자로 구성된다.
- 메시지 전송 : 한 객체가 다른 객체에게 도움을 요청하는 것
- 메시지 전송자 : 메시지를 전송하는 객체
- 메시지 수신자 : 메시지를 수신하는 객체

### 메시지와 메서드

객체지향에서 메시지와 메서드는 명확하게 구분된다.

메서드는 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 뜻한다. 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 점이 중요하다.

즉 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.

### 퍼블릭 인터페이스와 오퍼레이션

- 오퍼레이션 : 수행 가능한 행동에 대한 **추상화**
    - 흔히 내부 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.
    - ex) DiscountConditon 인터페이스에 정의된 isSatisfiedBy
- 메서드 : 메시지를 수신했을 때 실제로 실행되는 **구체적인 코드**
    - ex) PeriodConditon에 정의된 각각의 isSatisfiedBy 메서드

다형성을 적용하면 하나의 오퍼레이션에 대해 다양한 메서드를 구현할 수 있다.

### 시그니처

오퍼레이션이나 메서드의 명세를 나타낸 것으로 이름과 인자의 목록을 포함한다.

## 02 인터페이스와 설계 품질

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법들은 다음과 같다.

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리

### 디미터 법칙

"낯선 자에게 말하지 말라" 또는 "오직 인접한 이웃하고만 말하라" 로 요약할 수 있다. "오직 하나의 **도트**만 사용하라"라고 요약되기도 한다.

다음은 디미터 법칙을 위반하는 코드의 전형적인 모습니다. 
```
screening.getMovie().getDiscountConditions();
```

Screening 이 Movie를 포함하지 않도록 변경되거나 Movie가 DiscountConditon를 포함하지 않도록 변경된다면 ReservationAgency의 코드가 이리저리 흔들리게 된다.

따라서 디미터 법칙에서는 모든 클래스 C와 C에 구현된 모든 메서드 M에 대해 M이 메시지를 전송할 수 있는 모든 객체는 다음의 서술된 클래스로 제한한다.

- M의 인자로 전달된 클래스(C자체를 포함)
- C의 인스턴스 변수의 클래스

위의 코드를 디미터 법칙을 따르도록 개선하면 다음과 같다.

```
screening.calculateFee(audienceCount);
```
ReservatonAgency는 오직 Screening에게만 메시지를 전송할 수 있으며 Screening 내부의 어떤 정보도 알지 못한다.

디미터 법칙은 클래스를 캡슐화하기 위해 따라야 하는 구체적인 지침을 제공한다는 점에서 가치가 있다.

### 묻지 말고 시켜라

묻지 말고 시켜라 원칙에 따르도록 메시지를 결정하다보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가진 클래스를 얻을 확률이 높아진다.

### 의도를 드러내는 인터페이스

메서드의 이름을 지을 때 '어떻게'가 아니라 '무엇'을 하는지 드러내도록 한다.

'어떻게'를 먼저 고민하면 결과적으로 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민하게 된다. 반면 '무엇'을 하는지를 드러내면 객체가 협력 안에서 수행해야 하는 책임에 관해 고민하게 된다. 

```
public class PeriodConditon {
    public boolean isSatisfiedByPeriod(Screening screeing) {...}
}

public class SequenceCondition  {
    public boolean isSatisfiedBySequence(Screening screening) {...}
}

-> 위의 메서드는 구현 방식으로 모두 드러내는, 캡슐화를 위반하는 코드이다. 아래와 같이 무엇을 하는지 드러내는 코드로 변경할 수 있다.

public class PeriodConditon {
    public boolean isSatisfiedBy(Screening screeing) {...}
}

public class SequenceCondition  {
    public boolean isSatisfiedBy(Screening screening) {...}
}
```

클라이언트가 두 메서드를 가진 객체를 동일 타입으로 간주할 수 있도록 동일한 타입 계층으로 묶어서 처리할 수 있다.

## 03 원칙과 함정

맹목적으로 원칙을 추종하지 말고 현재 상황에 부적합하다고 판다되면 과감하게 원칙을 무시하라.

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

```
IntStream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count();
```

위의 코드는 도트를 계속해서 사용하지만 모두 IntStream이라는 동일한 클래스의 인스턴스를 반환한다. IntStream의 내부 구조가 외부로 유출되지않았기 때문에 캡슐은 그대로 유지된다.

기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.


