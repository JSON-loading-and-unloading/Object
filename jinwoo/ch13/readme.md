## 서브클래싱과 서브타이핑

상속은 첫 번째로 **타입 계층을 구현**하기 위해 사용된다. 타입 계층 안에서 부모 클래스는 자식 클래스의 일반화이고 자식 클래스는 부모 클래스의 특수화이다. 상속의 두 번째 용도는 **코드 재사용**이다. 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있고 점진적으로 애플리케이션의 기능을 확장할 수 있게 한다.

상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다. 상속은 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 설계의 변경과 진화를 방해한다. 타입 계층을 목표로하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있다.

이번 장에서는 올바른 타입 계층을 구성하는 원칙을 살펴보기로 한다.

## 01 타입

### 개념 관점의 타입

> 공통의 특징을 공유하는 대상들의 분류

타입은 심볼, 내연, 외연의 3가지 요소로 구성된다.

- 심볼 : 타입에 이름을 붙인 것
- 내연 : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동
- 외연 : 타입에 속하는 객체들의 집합

### 프로그래밍 언어 관점의 타입

> 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합

프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.

- 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
- 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.

### 객체지향 패러다임 관점의 타입

> 객체가 수신할 수 있는 메시지의 종류를 정의하는 것

객체가 수신할 수 있는 메시지의 집합은 **퍼블릭 인터페이스**이다. 따라서 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 

이는 지금껏 강조해왔던 객체에 관한 한 가지 사실을 다시 한 번 강조한다. 객체에게 중요한 것은 **속성이 아니라 행동**이다. 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면 서로 다른 타입이다.

## 02 타입 계층

### 타입 사이의 포함관계

타입은 집합의 관점에서 더 세분화된 타입의 집합을 부분집합으로 포함할 수 있다. 다른 타입을 포함하는 타입인 **슈퍼 타입**은 포함되는 타입인 **서브타입**보다 좀 더 일반화된 의미를 표현할 수 있다.

### 객체지향 프로그래밍과 타입 계층

객체의 타입을 결정하는 것은 퍼블릭 인터페이스이기 때문에 그 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다.

> 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것

> 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것 

서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다는 사실이 중요하다.

## 03 서브클래싱과 서브타이핑

객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이고, 타입 계층을 구현하는 방법은 상속을 이용하는 것이다. 상속을 이용해 타입 계층을 구현하면 부모클래스가 '슈퍼타입', 자식클래스가 '서브타입'의 역할을 한다.

이제부터 타입 계층을 구현할 때 지켜야 하는 제약사항을 클래스와 상속의 관점에서 살펴보자.

### 언제 상속을 사용해야 하는가?

마틴 오더스키에 따르면 두 질문에 '예'라고 답할 수 있는 경우에만 상속을 사용하라고 조언한다.

- 상속 관계가 is-a 관계를 모델링하는가?
- 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

### is-a 관계

두 클래스가 어휘적으로 is-a 관계를 모델링할 경우 상속을 사용해야 한다. 하지만 is-a 관계가 항상 명확한 것은 아니다.

다음의 예시는 어휘적 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 보여준다.

- 펭귄은 새다
- 새는 날 수 있다

```java
public class Bird {
    public void fly() {...}
}

public class Penguin extends Bird {
    ...
}
```
펭귄은 날지 못하는 새이다. 어휘적으로 펭귄은 새지만 새의 정의에 날 수 있다는 행동이 포함되므로 펭귄은 새의 서브타입이 될 수 없다. 이렇듯 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있음을 알 수 있다. 따라서 타입의 이름 사이에 개념적으로 어떤 연관성이 있더라도 행동에 연관성이 없으면 is-a 관계를 사용하지 말아야 한다.

### 행동 호환성

상속 관계를 판단하기 위해 타입이 행동과 관련이 있다는 사실이 중요하며 두 타입의 행동 호환 여부를 판단하는 기준은 **클라이언트의 관점**이다. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대하면 두 타입을 타입 계층으로 묶을 수 있다.

클라이언트가 다음과 같이 날 수 있는 새만 원한다고 가정하자.

```java
public void flyBird(Bird bird) {
    // 인자로 전달된 모든 bird는 날 수 있어야 한다.
    bird.fly();
}
```

Penguin은 날 수 없어 클라이언트의 기대를 저버리기 때문에 Bird의 서브타입이 아니다. 위 설계는 수정되어야 한다.

하지만 대부분의 사람들이 "펭귄은 새다"라는 말에 현혹당해 상속 계층을 유지하려 한다. 상속 관계를 유지하면서 문제를 해결하기 위해 다음의 시도를 해볼 수 있다.

- Penguin 의 fly 메서드를 오버라이딩해서 내부 구현 비워두기

    ```java
    public class Penguin extends Bird {
        ...
        @Override
        public void fly() {}
    }
    ```
    
    하지만 위의 클래스는 어떤 행동을 수행할거라는 기대에 부응하지 못하기 때문에 올바른 설계라고 볼 수 없다.

- Penguin 의 fly 메서드를 오버라이딩한 후 예외 던지기

    ```java
    public class Penguin extends Bird {
        ...
        @Override
        public void fly() {
            throw new UnsupportedOperationException();
        }
    }
    ```

    마찬가지로 flyBird 메서드는 fly 메시지를 전송한 결과로 예외가 던져질 것이라고 기대하지 않았을 것이다. 따라서 이 방법 없이 클라이언트 관점에서 Bird와 Penguin의 행동이 호환되지 않는다.

- flyBird메서드를 수정해서 인자로 전달된 타입이 Penguin이 아닐 경우에만 fly메시지를 전송하도록 한다.

    ```java
    public void flyBird(Bird bird) {
        // 인자로 전달된 모든 bird가 Penguin의 인스턴스가 아닐 경우에만
        // fly() 메시지를 전송한다
        if (!(bird instanceof Penguin)) {
            bird.fly();
        }
    }
    ```

    이 코드는 구체적인 클래스에 대한 결합도를 높이며 확장에 대해 유연하지 못한 설계이다.

### 클라이언트의 기대에 따라 계층 분리하기

살펴봤던 것처럼 행동 호환성을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법을 찾기 쉽지 않다. 문제를 해결할 수 있는 방법은 **클라이언트의 기대에 맞게 상속 계층을 분리하는 것**이다.
    
다음 코드는 새에는 날 수 없는 새와 날 수 있는 새의 두 부류가 존재하며 그중 펭귄은 날 수 없는 새에 속한다는 사실을 분명히 표현한다.

```java
public class Bird {
    ...
}

public class FlyingBird extends Bird {
    public void fly() {...}
    ...
}

public class Penguin extends Bird {
    ...
}
```

```java
public void flyBird(FlyingBird bird) {
    bird.fly();
}
```

이 문제를 해결하는 다른 방법은 **클라이언트에 따라 인터페이스를 분리하는 것**이다. 이러한 설계 원칙을 **인터페이스 분리 원칙(ISP)**라고 부른다.

클라이언트가 오직 fly 메시지만 전송하기를 원한다면 이 클라이언트에게는 fly 메시지만, walk 메시지만 전송하기를 원한다면 이 클라이언트에게는 walk 메시지만 보여야 한다. 가장 좋은 방법은 fly 오퍼레이션을 가진 Flyer 인터페이스와 walk 오퍼레이션을 가진 Walker 인터페이스로 분리하는 것이다. 이제 Bird와 Penguin은 자신이 수행할 수 있는 인터페이스만 구현할 수 있다.

클라이언트에 따라 인터페이스를 분리하면 변경에 대한 영향을 더 세밀하게 제어할 수 있다. 대부분의 경우 인터페이스는 클라이언트의 요구가 바뀜에 따라 변경되기 때문이다.

### 서브클래싱과 서브타이핑

상속은 2가지 목적을 위해 사용된다. 하나는 코드의 재사용이고 다른 하나는 타입 계층을 구성하기 위해서다. 이를 각각 **서브클래싱**과 **서브타이핑**이라고 한다.

서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다(**행동 호환성**). 또한 자식 클래스가 부모 클래스를 대신할 수 있기 위해서는 자식 클래스가 부모 클래스가 사용되는 모든 문맥에서 자식 클래스와 동일하게 행동할 수 있어야 한다(**대체 가능성**).

행동 호환성과 대체 가능성은 올바른 상속 관계를 구축하기 위해 따라야 할 지침이라고 할 수 있다. 그리고 이 지침은 **리스코프 치환 원칙**이라는 이름으로 정의되고 소개되고 있다.

## 04 리스코프 치환 원칙

> 서브 타입은 그것의 기반 타입에 대해 대체 가능해야 한다. 즉 앞에 설명한 행동 호환성을 설계 원칙으로 정리한 것이다. 

정사각형과 직사각형의 상속 관계는 리스코프 치환 원칙을 위반하는 고전적인 사례 중 하나다.

개념적으로 정사각형(Square)는 직사각형(Rectangle)의 특수한 경우이고 직사각형은 정사각형의 일반적인 경우이기 때문에 둘을 어휘적으로 is-a관계라고 볼 수 있다. is-a 관계는 상속을 이용해 구현할 수 있다.

정사각형은 너비와 높이가 동일해야 하기 때문에 width와 height 값을 동일하게 설정한다. 하지만 문제는 Square는 Rectangle의 자식 클래스이기 때문에 Rectangle이 사용되는 모든 곳에서 Rectangle로 업캐스팅될 수 있기 때문에 발생한다. 주어진 width, height로 Rectangle을 resize하는 메서드를 Square로 실행시켰을 때 우리의 예상과 다른 값이 나온다. Square를 전달했을 때 height의 값으로 width가 설정된다.

이는 두 클래스가 서브타이핑 관계가 아니라 서브클래싱 관계임을 보여준다. Square는 Rectangle의 구현을 재사용하고 있을 뿐이다. 중요한 것은 클라이언트 관점에서 행동이 호환될 때만 자식 클래스가 부모 클래스 대신 사용될 수 있다.

### 클라이언트와 대체 가능성

Square가 Rectangle을 대체할 수 없는 이유는 클라이언트 관점에서 둘이 다르기 때문이다. Rectangle을 사용하는 클라이언트는 Rectangle의 너비와 높이가 다를 수 있다는 가정하에 코드를 개발한다. 반면 Square는 너비와 높이가 항상 같다. 따라서 Rectanlge을 Square로 대체할 경우 Rectangle에 대해 세워진 가정을 위반할 확률이 높다.

리스코프 치환 원칙은 상속 관계에 있는 두 클래스 사이의 관계를 클라이언트와 떨어트려 놓고 판단하지 말라고 강조한다. 상속 관계는 클라이언트의 관점에서 자식 클래스가 부모 클래스를 대체할 수 있을때만 올바르다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다

리스코프 치환 원칙은 클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다. 새로운 자식 클래스를 추가하더라도 클라이언트 입자에서는 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다. 따라서 리스코프 치환 원칙은 개방-폐쇄 원칙을 만족하는 설계를 위한 전제 조건이다.

## 05 계약에 의한 설계와 서브타이핑

클라이언트 관점에서 자식 클래스가 부모 클래스의 행동을 대체한다, 보존한다는 의미는 클라이언트와 서버 사이의 계약을 서브타입이 준수하는 것을 의미한다.

클라이언트와 서버 사이의 협력을 **계약에 의한 설계**라고 한다. 계약에 의한 설계는 클라이언트는 정상적으로 메서드를 실행하기 위해 만족시켜야 하는 **사전조건**이 있고 메서드가 실행된 후 서버가 클라이언트에게 보장해야하는 **사후조건**, 메서드 실행 전과 실행 후 인스턴스가 만족시켜야 하는 **클래스 불변식**으로 구성된다. 

Movie와 DiscountPolicy의 예시를 보자.

```java
public class Movie {
    ...
    public Money calculateMovieFee(Screening screening) {
        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
}
```

```java
public class Movie {
    ...
    public Money calculateDiscountAmount(Screening screening) {
        for(DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                return getDiscountAmount(screening);
            }
        }
        
        return screening.getMovieFee();
    }
}
```

DiscountPolicy의 calculateDiscountAmount 메서드는 인자로 전달된 screening이 null인지 확인하지 않는다. null이 전달된다면 NPE 예외가 던져질 것이다. 클라이언트가 전달하는 screening의 값이 null이 아니고 영화 시작 시간이 아직 지나지 않았다는 가정은 **사전조건**에 해당된다.

calculateDiscountAmount 메서드의 반환값은 항상 null이 아니어야 한다. 또한 추가로 반환되는 값은 청구되는 요금이기 때문에 최소 0보다 커야 한다는 **사후조건**에 해당된다.

DiscountPolicy의 자식클래스인 AmountDiscountPolicy, PercentDiscountPolicy는 Movie와 DiscountPolicy 사이에 체결된 계약을 만족하기 때문에 올바른 서브타이핑 관계라고 할 수 있다.

### 서브타입과 계약

계약의 관점에서 상속이 초래하는 가장 큰 문제는 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 수 있다는 것이다. 

> 메서드 오버라이딩을 통해 슈퍼타입에서 정의한 사전조건보다 더 약한 사전조건을 정의하고 있다면 그 타입은 서브타입이 될 수 있지만 더 강한 사전조건을 정의한다면 서브타입이 될 수 없다.

```java
public class BrokenDiscountPolicy extends DiscountPolicy {

    public BrokenDiscountPolicy(DiscountCondition... conditions) {
        super(conditions);
    }

    @Override
    public Money calculateDiscountAmount(Screening screening) {
        checkPrecondition(screening);                 // 기존의 사전조건
        checkStrongerPrecondition(screening);         // 더 강력한 사전조건

        Money amount = screening.getMovieFee();
        checkPostcondition(amount);                   // 기존의 사후조건
        checkStrongerPostcondition(amount);           // 더 강력한 사후조건
        return amount;
    }
}
```

새로운 사전조건은 checkStrongerPreconditon 메서드로 구현돼 있으며 종료 시간이 자정을 넘는 영화를 예매할 수 없다는 것이다. 문제는 클라이언트인 Movie는 사전 조건을 만족시키기 위해 null이 아니면서 시작시간이 현재 시간 이후인 Screening만 전달한다. 따라서 자정이 지난 후에 종료되는 Screening을 전달하더라도 문제가 없다고 가정한다. 하지만 BrokenPolicy의 사전조건은 이를 허용하지 않기 때문에 해당 협력은 실패한다.

> 어떤 타입이 슈퍼타입에서 정의한 사후조건보다 더 강한 사후조건을 정의하더라도 그 타입은 여전히 서브타입이자만 더 약한 사후조건을 정의한다면 서브타입의 조건이 깨진다.

BrokenDiscountPolicy는 DiscountPolicy에 정의된 사후조건인 amount가 null이 아니고 0보다 커야한다는 제약에 최소 1000원 이상되어야한다는 새로운 사후조건을 추가했다. Movie는 최소한 0보다 큰 금액만 반환받으면 된다. 따라서 Movie와 DiscountPolicy 사이에 체결된 계약을 위반하지 않는다.




