# **15 디자인패턴과 프레임워크**

- 디자인 패턴
    - 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법
    - 설계를 재사용하는 것이 목적
- 프레임워크
    - 설계와 코드를 함께 재사용하기 위한 것
    - 애플리케이션 아키텍처를 구현 코드 형태로 제공한다
    - 특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.
- 디자인 패턴과 프레임워크 모두 협력을 일관성 있게 만들기 위한 방법이다.

## **01 디자인 패턴과 설계 재사용**

### **소프트웨어 패턴**

- 패턴의 정의보다 패턴이라는 용어 자체가 풍기는 뉘앙스를 이해해야 한다.
- 패턴의 핵심적인 특징
    - 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
    - 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며 다른 사람과 의사소통할 수 있다.
    - 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적 코드 작성을 돕는다.
    - 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

### **패턴 분류**

- 패턴은 범위나 적용 단계에 따라 4가지로 나눌 수 있다.
    - 아키텍처 패턴
    - 분석 패턴
    - 디자인 패턴
    - 이디엄
- 아키텍처 패턴
    - 디자인 패턴의 상위 개념으로 소프트웨어 전체적인 구조를 결정하기 위해 사용할 수 있다.
    - 미리 정의된 서브시스템들을 제공하고 각 서브시스템들의 책임을 정의하며 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
- 이디엄 패턴
    - 디자인 패턴의 하위 개념으로 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.
    - 주어진 언어의 기능을 사용해 컴포넌트, 혹은 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
    - 이디엄은 언어에 종속적이기 때문에 특정 언어의 이디엄이 다른 언어에서는 무용지물이 될 수 있다.
- 분석 패턴
    - 위 패턴들이 주로 기술적 문제를 해결하는데 초점을 둔다면 분석 패턴은 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
    - 분석 패턴은 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
    - 하나의 도메인에 대해서만 적절할 수도 있고 여러 도메인에 걸쳐 적용할 수도 있다.

### **패턴과 책임-주도 설계**

- 객체지향 설계에서 가장 중요한 일은 올바른 책임을 올바른 객체에게 할당하고 객체 간 유연한 협력 관계를 구축하는 일이다.
    - 책임과 협력의 윤곽은 다양한 요소들의 트레이드오프를 통해 결정된다.
- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 탬플릿이다.
    - 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과 책임, 협력의 훌륭한 예제를 제공한다.
    - 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다.
- 패턴의 구성 요소는 클래스가 아니라 ‘역할’이다.
    - 이는 패턴 탬플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다.
    - 하나의 객체가 여 역할을 수행하거나 다수의 클래스가 동일한 역할을 구현할 수도 있다.

### **캡슐화와 디자인 패턴**

- 대부분의 디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다. 따라서 각 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의하고 있다.
- STRATEGY 패턴을 사용하면 결합도는 낮게 유지할 수 있기 때문에 런타임에 알고리즘을 변경할 수 있다.
- TEMPLATE METHOD 패턴은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다. 다만 합성보다는 결합도가 높은 상속을 사용했기 때문에 STRATEGY 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다.
    - 결합도는 높아지지만 복잡도는 낮아진다.
- COMPOSITE 패턴은 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화하는 것이 목적이다.
- DECORATOR 패턴은 선택적인 행동의 개수와 순서에 대한 변경을 캡슐화 할 수 있다.

### **패턴은 출발점이다**

- 패턴은 출발점이지 목적지가 아니다.
- 패턴을 사용하면서 부딪히는 대부분의 문제는 패턴의 맹목적 사용 시에 발생한다.
    - 해결하려는 문제가 아니라 패턴이 제시하는 구조를 맹목적으로 따르는 것은 불필요하게 복잡하고 난해하며, 유지보수하기 어려운 시스템을 낳는다.
    - 명확한 트레이드오프 없이ㅏ 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.
- 정당한 이유 없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다. 패턴은 복잡성의 가치가 단순성을 넘어설 때만 정당화돼야 한다.
- 패턴을 가장 효과적으로 적용하는 방법은 패턴을 지향하거나 패턴을 목표로 리팩터링하는 것이다.
    - 패턴이 적용된 최종 결과를 이해하는 것 보다 패턴을 목표로 리팩터링하는 이유를 이해하는 것이 훨씬 가치있다.

## **02 프레임워크와 코드 재사용**

### **코드 재사용 대 설계 재사용**

- 디자인 패턴은 프로그래밍 언어에 독립적인 재사용 가능한 설계 아이디어를 제공하는 것을 목적으로 하기 때문에 언어에 종속적인 구현 코드를 정의하기 않아 디자인 패턴을 적용하기 위해선 설계 아이디어를 프로그래밍 언어의 특성에 맞춰 가공해야 하고 매번 구현 코드를 재작성해야 한다는 단점이 있다.

- 가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절하게 조합하는 것이다.
    - 추상적인 수준에서의 설계 재사용을 강조하는 디자인 패턴은 재사용을 위해 매번 유사한 코드를 작성해야만 한다.
    - 설계를 재사용하면서도 유사한 코드를 반복적으로 구현하는 문제를 피할 수 있는 방법은 없을까? → 프레임워크
- 프레임워크
    - 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계 → 프레임워크의 구조적인 측면
    - 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격 → 프레임워크의 사용 목적
    - 프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.
    - 애플리케이션을 확장할 수 있도록 부분적으로 구현돤 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트도 함께 제공

### **상위 정책과 하위 정책으로 패키지 분리하기**

- 프레임워크의 핵심은 추상화이다.
    - 추상 클래스와 인터페이스는 일관성 있는 협력을 만드는 핵심 재료다.
    - 협력을 일관성 있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화해야 한다.
    - 협력을 구현하는 코드 안의 의존성은 가급적이면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 해야 한다.
- 객체지향 이전에는 상위 레벨 모듈이 하위 모듈에, 상위 정책이 구체적인 사항에 의존했다.
    - 그러나 상위 정책은 상대적으로 변경에 안정적이지만 세부 사항은 자주 변경된다.
        - 이런 경우 변경에 대한 파급 효과로 인해 상위 정책이 불안정해질 것이다.
    - 상위 정책은 세부 사항에 비해 재사용될 가능성이 높다.
    - 상위 정책이 세부 사항에 의존하게 되면 상위 정책이 필요한 모든 경우에 세부 사항도 항상 함께 존재해야 하기 때문에 상위 정책의 재사용성이 낮아진다.
- 의존성 역전 원칙으로 상위 정책과 세부 사항 모두 추상화에 의존하게 만들면 이 문제를 해결 할 수 있다.
- 변하는 부분과 변하지 않는 부분을 서로 분리해야 한다.
    - 변하는 것은 구체적인 세부 사항이고, 변하지 않는 것은 상위 정책에 속하는 역할들의 협력 구조이다.
    - 프레임워크는 여러 애플리케이션에 걸쳐 재사용 가능해야 하기 때문에 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 별도의 배포 단위로 분리해야 한다.
    - 이를 위해 변하는 부분과 변하지 않는 부분을 별도의 패키지로 분리하고 세부 사항을 구현한 패키지가 항상 상위 정책을 구현한 패키지에 의존하도록 구성해야 한다.

### **제어 역전 원리**

- 의존성 연적 원리는 전통적인 설계 방법과 객체지향을 구분하는 가장 핵심적인 원리다. 의존성 역전 원리에 따라 구축되지 않는 시스템은 협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.
- 제어 역전 원리 (Inversion of Control)
    - 의존성을 역전시킨 객체지향 구조에서는 프레임워크가 애플리케이션에 속하는 서브 클래스를 호출한다.
    - 따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다.
        - 의존성을 역전시키면 제어 흐름의 주체 역시 역전된다(제어 역전 원리)
    - 프레임워크에선 일반적 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 동작은 비워둔다.
        - 완성되지 않은 채로 남겨진 동작을 훅(hook)이라고 부른다.
        - 훅의 구현 방식은 애플리케이션의 컨텍스트에 따라 달라진다.
    - 협력을 제어하는 것은 프레임워크이다. 우리는 프레임워크가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐이다.
    
- 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 아이디어다. 최소 세가지의 서로 다른 시스템에 문제 없이 적용할 수 있고 유용한 경우에만 패턴으로 간주할 수 있다.
- 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점이다. 패턴은 경험의 산물이다.
- 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기 때문에 패턴에서 가장 중요한 요소는 패턴의 이름이다.
- 디자인 패턴
    - 중간 규모의 패턴으로 특정한 설계 문제를 해결하는 것을 목적으로 하며, 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다.
- 패턴이 설계의 목표가 돼서는 안 된다. 패턴은 단지 목표로 하는 설계에 이를 수 있는 방향을 제시하는 것 뿐이다.
    - 디자인 패턴이 현재 상황에 적합하지 않다면 그대로 따르지 말고 목적에 맞게 패턴을 수정해야 한다.
- 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.
    - 오랜 시간 동안 개발자들은 부품을 조립해서 제품을 만드는 것처럼 별도의 프로그래밍 없이 기존 컴포넌트를 조립해서 애플리케이션을 구축하는 방법을 추구해왔다.
    - 아이디어 자체는 이상적이지만 실제로 적용하는 과정에서 현실적이진 않음을 알게되었다.
        - 애플리케이션과 도메인의 다양성으로 인해 문제가 아주 비슷한 경우는 거의 없기 때문이다.
- 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다.
- 시스템이 진화하는 방향에는 항상 의존성 역전 원리를 따르는 설계가 존재해야 한다.