# 13 서브클래싱과 서브타이핑

상속은 두 가지 용도로 사용된다. 

- 상속의 첫 번째 용도는 타입 계층을 구현하는 것이다.
    - 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.
    - 타입 계층 안에서 부모 클래스는 자식 클래스의 일반화이고 자식 클래스는 부모 클래스의 특수화이다.
- 상속의 두 번째 용도는 코드 재사용이다.
    - 상속은 간단한 선언만으로 부모 클래스의 코드를 재사용할 수 있는 마법의 주문과도 같다.
    - 상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다.
    - 하지만 재사용을 위해 상속을 사용할 경우 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경하기 어려운 코드를 얻게 될 확룰이 높다.
- 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 타입 계층을 구현하는 것이어야 한다. 상속은 코드를 쉽게 재사용할 수 있는 방법을 제공하지만 부모 클래스와 자식 클래스를 강하게 결합시키기 때문에 설계의 변경과 진화를 방해한다.
- 반면 타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.
- 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 행동을 기반으로 타입 계층을 구성해야 한다.

## 01 타입

### 개념 관점의 타입

- 공통의 특징을 공유하는 대상들의 분류다.
- 타입은 심볼, 내연, 외연 세 가지 요소로 구성된다.
    - 심볼 : 타입에 이름을 붙인 것. ex) 프로그래밍 언어
    - 내연 : 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다.
        - ex) 컴퓨터에게 특정한 작업을 지시하기 위한 어휘와 문법적 규칙의 집합 ← 프로그래밍 언어(심볼)의 정의
    - 외연 : 타입에 속하는 객체들의 집합
        - ex) 자바, 루비, 자바스크립트, C … ← 프로그래밍 언어(심볼) 타입

### 프로그래밍 언어 관점의 타입

- 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다. (호출 가능한 오퍼레이션의 집합)
- 프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다
    - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다
        - 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 프로그래머의 실수를 막아준다.
        - ex) 자바에서 + 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다. 하지만 C++와 C#에서는 연산자 오버로딩을 통해 + 연산자를 사용하는 것이 가능하다.
    - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
        - 객체를 생성하는 방법에 대한 문맥을 결정하는 것은 바로 객체의 타입이다.
        - ex) 자바에서 a+b라는 연산이 있을 때 a,b의 타입이 int라면 두 수를 더할 것이고, a와b의 타입이 String이라면 두 문자열을 하나의 문자열로 합칠 것이다.
- 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.

### 객체지향 패러다임 관점의 타입

- 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다.
- 객체가 수신할 수 있는 메시지의 집합을 퍼블릭 인터페이스라고 한다. 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다.
- 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
- 객체에게 중요한 것은 속성이 아니라 행동이다. 어떤 객체들이 동일한 상태를 가지고 있더라도 퍼블릭 인터페이스가 다르면 서로 다른 타입이다.
- 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이다.

## 02 타입 계층

### 타입 사이의 포함관계

- 타입은 집합의 관점에서 더 세분화된 타입의 집합을 부분집합으로 포함할 수 있다.
- 타입 계층을 구성하는 두 타입 간의 관계에서 다른 타입을 포함하는 더 일반적인 타입을 슈퍼 타입이라고 부르고 포함되는 더 특수한 타입을 서브타입이라고 부른다.
- 슈퍼타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
    - 집합이 다른 집합의 모든 멤버를 포함한다.
    - 타입 정의가 다른 타입보다 좀 더 일반적이다.
- 서브타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
    - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
    - 타입 정의가 다른 타입보다 좀 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층

- 객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.
- 일반적인 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 일반적인 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
- 특수한 타입이란 비교하려는 타입에 속한 객체들의 퍼블릭 인터페이스보다 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 타입을 의미한다.
- 퍼블릭 인터페이스의 관점에서 슈퍼타입은 다음과 같이 정의된다
    - 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것이다.
- 서브타입은 다음과 같이 정의된다
    - 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것이다.
- 중요한 것은 서브타입의 인스턴스가 슈퍼타입의 인스턴스로 간주될 수 있다는 점이다.

## 03 서브클래싱과 서브타이핑

- 객체지향 프로그래밍 언어에서 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다. 그리고 타입 계층을 구현하는 일반적인 방법은 상속을 이용하는 것이다.
- 상속을 이용해 타입 계층을 구현한다는 것은 부모 클래스가 슈퍼타입의 역할을, 자식 클래스가 서브타입의 역할을 수행하도록 클래스 사이의 관계를 정의한다는 것을 의미한다.

### 언제 상속을 사용해야 하는가?

- 마틴 오더스키는 다음과 같은 질문을 해보고 두 질문에 모두 예라고 답할 수 있는 경우에만 상속을 사용하라고 조언한다.
    - 상속 관계가 is-a 관계를 모델링하는가?
    - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?

**is-a 관계**

- 어떤 타입 S가 다른 타입 T의 일종이라면 타입 S는 타입 T다 (S is-a T)
- 하지만 is-a 관계가 직관적인것은 아니다.
    - 펭귄은 새다
    - 새는 날 수 있다
    
    ```java
    public class Bird {
        public void fly() {...}
    }
    
    public class Penguin extends Bird {
        ...
    }
    ```
    
    - 어휘적으로 펭귄은 새지만 새의 정의에 날 수 있다는 행동이 포함되므로 펭귄은 새의 서브타입이 될 수 없다. 만약 새의 정의에 날 수 있다는 행동이 포함된다면 펭귄은 새의 서브타입이 될 수 없다. 이 경우에는 어휘적인 관점과 행동 관점이 일치하게 된다.
    - 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다. 그에 따라 올바른 타입 계층이라는 의미 역시 문맥에 따라 달라질 수 있다.
    - 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 더 중요하다. 따라서 어떤 두 대상을 언어적으로 is-a라고 표현할 수 있어도 바로 상속을 적용하는 것은 좋지 않다.

**행동 호환성**

- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점이다.
- 클라이언트가 다음과 같이 날 수 있는 새만 원한다고 가정하자.

```java
public void flyBird(Bird bird) {
    // 인자로 전달된 모든 bird는 날 수 있어야 한다.
    bird.fly();
}
```

- 현재 Penguin은 Bird의 자식 클래스이기 때문에 flyBird 메서드의 인자로 Penguin의 인스턴스가 전달되는 것을 막을 수 있는 방법이 없다.
- 하지만 Penguin은 날 수 없어 클라이언트의 기대를 저버리기 때문에 Bird의 서브타입이 아니기 때문에 이 설계는 수정되어야 한다.
- 하지만 대부분의 사람들은 "펭귄은 새다"라는 말에 현혹당해 상속 계층을 유지하려 할 것이다. 상속 관계를 유지하면서 문제를 해결하기 위해 다음의 시도를 해볼 수 있다.
- Penguin 의 fly 메서드를 오버라이딩해서 내부 구현 비워두기
    
    ```java
    public class Penguin extends Bird {
        ...
        @Override
        public void fly() {}
    }
    ```
    
    - 하지만 위의 클래스는 어떤 행동도 수행하지 않기 때문에 모든 bird가 날 수 있다는 클라이언트의 기대를 만족시키지 못하기 때문에 올바른 설계라고 볼 수 없다.
    - Penguin과 Bird의 행동은 호환되지 않는다.
- Penguin 의 fly 메서드를 오버라이딩한 후 예외 던지기
    
    ```java
    public class Penguin extends Bird {
        ...
        @Override
        public void fly() {
            throw new UnsupportedOperationException();
        }
    }
    ```
    
    - 이 경우에도 결과로 예외가 던져질 것이라고 기대하지 않았을 것이기 때문에 클라이언트 관점에서 Bird와 Penguin의 행동이 호환되지 않는다.
- flyBird 메서드를 수정해서 인자로 전달된 bird의 타입이 Penguin이 아닐 경우에만 fly메시지를 전송하도록 한다.
    
    ```java
    public void flyBird(Bird bird) {
        // 인자로 전달된 모든 bird가 Penguin의 인스턴스가 아닐 경우에만
        // fly() 메시지를 전송한다
        if (!(bird instanceof Penguin)) {
            bird.fly();
        }
    }
    ```
    
    - 만약 Penguin 이외에 날 수 없는 또 다른 새가 상속 계층에 추가된다면 flyBird 메서드 안에서 새로운 타입을 체크하는 코드를 추가해야 한다. 이는 new 연산자와 마찬가지로 구체적인 클래스에 대한 결합도를 높인다.
    - 일반적으로 객체의 타입을 확인하는 코드는 새로운 타입을 추가할 때마다 코드 수정을 요구하기 때문에 개방-폐쇄 원칙을 위반한다.

### 클라이언트 기대에 따라 계층 분리하기

- 행동 호환성을 만족시키지 않는 상속 계층을 그대로 유지한 채 클라이언트의 기대를 충족시킬 수 있는 방법은 찾기 어렵다. 문제를 해결할 수 있는 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것뿐이다.
- 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족시킬 수 있을 것이다.

```java
public class Bird { ... }

public class FlyingBird extends Bird {
    public void fly() { ... }
}

public class Penguine extends Bird { ... }
```

- 이제 flyBird 메서드는 FlyingBird 타입을 이용해 날 수 있는 새만 인자로 전달돼야 한다는 사실을 코드에 명시할 수 있다.

```java
public void flyBird(FlyingBird bird) {
    bird.fly();
}
```

- 클라이언트에 따라 인터페이스를 분리하는 방법도 있다.
    - Bird는 날 수 있으면서 걸을 수 있어야 하고 Penguin은 걸을 수만 있다고 가정
    - 이를 fly 오퍼레이션을 가진 Flyer 인터페이스와 walk 오퍼레이션을 가진 Walker 인터페이스로 분리하는 것이다.
    - 이제 Bird와 Penguin은 자신이 수행할 수 있는 인터페이스만 구현할 수 있다.

```java
public Bird implements Flyer, Walker { ... }

public Penguine implements Walker { ... }
```

- Penguin이 Bird의 코드를 재사용하고 싶다면 상속할 순 있지만 fly 오퍼레이션이 추가되어 버린다. 더 좋은 방법은 합성을 사용하는 것이다.
- 클라이언트에 따라 인터페이스를 분리하면 변경 영향을 더 세밀하게 제어할 수 있게 된다.
    - 대부분의 경우 인터페이스는 클라이언트의 요구가 바뀜에 따라 변경된다. 클라이언트에 따라 인터페이스를 분리하면 각 클라이언트의 요구가 바뀌더라도 영향의 파급 효과를 효과적으로 제어할 수 있게 된다.
    - 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 **인터페이스 분리 원칙 (Interface Segregation Principle, ISP)** 이라고 부른다.

### 서브 클래싱과 서브 타이핑

- 사람들은 상속을 사용하는 두 가지 목적에 특별한 이름을 붙였는데 서브클래싱과 서브타이핑이 그것이다.
- 서브클래싱(subclassing)
    - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
    - 자식 클래스과 부모 클래스의 행동이 호환되지 않아 자식이 부모를 대체할 수 없다.
    - ‘구현 상속’ 또는 ‘클래스 상속’이라 부른다.
- 서브타이핑(subtyping)
    - 타입 계층을 구성하기 위해 상속을 사용하는 경우
    - 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식이 부모를 대체할 수 있다.
    - ‘인터페이스 상속’이라 부른다.
- 슈퍼타입과 서브타입 사이에서 가장 중요한 것은 퍼블릭 인터페이스이다.
    - 슈퍼타입 인스턴스를 요구하는 모든 곳에서 서브타입의 인스턴스를 대신 사용하기 위해 만족해야 하는 최소한의 조건은 서브타입의 퍼블릭 인터페이스가 슈퍼타입에서 정의한 퍼블릭 인터페이스와 동일하거나 더 많은 오퍼레이션을 포함해야 한다는 것이다.
        - 따라서 서브타입이 슈퍼타입의 퍼블릭 인터페이스를 상속받는 것처럼 보이게 된다. 이것이 서브타이핑을 인터페이스 상속이라고 부르는 이유다.
    - 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성을 만족시켜야 한다.
    - 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성을 포함한다.

## 04 리스코프 치환 원칙

- 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
    - 서브타입은 그것 기반 타입에 대해 대체 가능해야 한다
    - 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 리스코프 치환 원칙은 앞에서 논의한 행동 호환성을 설계 원칙으로 정리한 것이다.
- 리스코프 치환 원칙에 따르면 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑이라고 불러야한다.

### 클라이언트와 대체 가능성

- 리스코프 치환 원칙은 자식이 부모를 대체하기 위해서 부모에 대한 클라이어트의 가정을 준수해야 한다는 것을 강조한다.
- 리스코프 치환 원칙은 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다는 아주 중요한 결론을 이끈다. 어떤 모델의 유효성을 클라이언트 관점에서 검증 가능하다는 것이다.
- 행동 호환성과 리스코프 치환 원칙에서 중요한 것은 대체 가능성을 결정하는 것은 클라이언트라는 것이다.

### is-a 관계 다시 살펴보기

- 클라이언트 관점에서 자식 클래스의 행동이 부모 클래스의 행동과 호환되지 않고 그로 인해 대체가 불가능하다면 어휘적으로 is-a라고 할 수 있다고 해도 관계적으로는 is-a 관계라 할 수 없다.
- 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계다.

### 리스코프 치환 원칙은 유연한 설계의 기반이다

- 리스코프 치환 원칙은 클라이언트가 어떤 자식과도 안정적으로 협력할 수 있는 상속 구조를 구현할 수 있는 가이드라인을 제공한다.
    - 클라이언트 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다.
- 리스코프 치환 원칙을 따르는 설계는 유연성과 확장성이 높다.
- 자식 클래스가 부모 클래스를 클라이언트 관점에서 대체 가능하다면 확장을 위해 클래스를 추가하더라도 코드를 수정할 필요가 없어진다. (개방-폐쇄 원칙 지원)

### 타입 계층과 리스코프 치환 원칙

- 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나일 뿐이다.
    - 자바와 C# 의 인터페이스 또는 스칼라의 트레이트, 동적 타입 언어의 덕 타이핑 등의 기법을 사용하면 클래스 사이의 상속을 사용하지 않고 서브타이핑 관계를 구현할 수 있다.
    - 어느 방법을 사용해 리스코프 지환 원칙을 준수해야만 서브타이핑 관계라고 말할 수 있다.
- 코드 재사용 목적으로 클래스 상속을 남용하면 리스코프 치환 원칙을 위반하게 된다.

## 05 계약에 의한 설계와 서브타이핑

- 계약에 의한 설계 (DBC)
    - 클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약 관점으로 표현하는 것
- 계약에 의한 설계는 다음과 같이 세 가지 요소로 구성된다.
    - 사전 조건: 클라이언트가 정상적으로 메서드 실행하기 전에 만족시켜야 하는
    - 사후 조건: 메서드 실행된 후에 서버가 클라이언트에게 보장해야 하는
    - 클래스 불변식: 메서드 실행 전후로 인스턴스가 만족시켜야 하는
- 서브타입이 리스코프 치환 원칙을 만족시키기 위해선 클라이언트와 슈퍼타입 간 체결된 ‘계약’을 준수해야 한다.
- 계약에 의한 설계에 따르면 협력하는 클라이언트와 슈퍼타입의 인스턴스 사이에는 어떤 계약이 맺어져있다.
    - 클라이언트와 슈퍼타입은 이 계약을 준수할 때만 정상적으로 협력할 수 있다.
- 리스코프 치환 원칙은 서브타입이 그것의 슈퍼타입을 대체할 수 있어야 하고 클라이언트가 차이점을 인식하지 못한 채 슈퍼타입의 인터페이스를 이용해 서브타입과 협력할 수 있어야 한다고 말한다. 클라이언트 입장에서 서브타입은 정말 슈퍼타입의 한 종류여야 하는 것이다.

### 서브타입과 계약

- 계약 관점에서 상속이 초래하는 가장 큰 문제는 자식이 부모 메서드를 오버라이딩할 수 있다는 것이다.
- 자식 클래스가 부모 클래스의 서브타입이 되기 위해서는 다음 조건을 만족시켜야 한다.
    - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
    - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
    - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
    - 서브타입에 더 약한 사후조건을 정의할 수 없다.
- 즉 어떤 타입이 슈퍼타입의 서브타입이 되려면
    - 더 강한 사전조건을 정의할 수 없다.
    - 더 약한 사후조건을 정의할 수 없다.