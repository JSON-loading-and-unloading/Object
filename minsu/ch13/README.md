# 서브클래싱과 서브타이핑
## 01 타입
###  개념 관점의 타입
- 정의
   - 공통의 특징을 공유하는 대상들의 분류
- 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 함
- 타입의 세 가지 요소
  - 심볼: 타입에 이름을 붙인 것
  - 내연 : 타입의 정의로 타이벵 속하는 객체들이 가지는 공통적인 속성이나 행동
  - 외연: 타입에 속하는 객체들의 집합

 ### 프로그래밍 언어 관점의 타입
- 정의
   - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
- 두 가지 목적
  - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
  - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.

### 객체지향 패러다임 관점의 타입
- 정의
  - 객체의 퍼블릭 인터페이스(객체가 수신할 수 있는 메시지의 집합)을 정의하는 것
  - 동일한 퍼블리 인터페이스를 제공하는 객체들은 동일한 타입으로 본류
- 객체에게 중요한 것
  - 속성이 아닌 행동
  - 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 함   
  -> 동일한 상태이라도 퍼블릭 인터페이스가 다르면 서로 다른 타입   
  -> 반대로 어떤 객체들이 내부 상태가 달라도 동일한 퍼블릭 인터페이스를 공유하면 같은 타입


## 02 타입 계층
### 타입 사이의 포함관계
- 타입은 객체들의 집합이기 때뭉네 다른 타입을 포함할 수 있다.

<img width="452" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/bf1cfefb-b8d3-4d99-a9c9-c5ecbc254f9d">

이를 집합의 관점에서 더 세분화된 타입의 집합을 부분집합으로 포함할 수 있다.

<img width="527" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/79693d8e-3b04-4633-a155-fd60138c3ca5">

- 포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적이다.
- 포함되는 타입은 외연 관점에서는 더 작고 내연 관점에서는 더 특수하다.


<img width="588" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/4fece4b8-e472-4971-b215-4737794501a8">

- 슈퍼 타입: 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입
- 서브타입: 더 특수한 타입


내연과 외연의 관점에서 일반화와 특수화   
- 일반화:
     - 내연 관점에서 일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정
     - 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋
- 특수화:
    - 내연 관점에서 특수한 타입의 정의는 일반적인 타입의 정의를 좀 더 구체화한 것
    - 외연의 관점에서 특수한 타입에 속한 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋


슈퍼타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
- 집합이 다른 집합의 모든 멤버를 포함한다.
- 타입 정의가 다른 타입보다 좀 더 일반적이다.

서브타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
- 타입 정의가 다른 타입보다 좀 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층
퍼블릭 인터페이스의 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다.
- 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
- 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것
- 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입이다.
   - 따라서, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.


## 03 서브클래싱과 서브타이핑
### 언제 상속을 사용해야 하는가?
- 상속의 올바른 용도는 타입 계층을 구현하는 것
- 다음 질문에 모두 "예"라고 답하면 상속을 사용
  - 상속 관계가 is-a 관계를 모델링하는가? (자식 클래스는 부모클래스다가 성립하는가?)
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? (행동 호환성이 되는가?)

### is-a 관계
- 어떤 타입 S가 다른 타입 T의 일종이라면 s is-a T라고 말할 수 있다.
- 하지만 is-a 관계가 항상 직관적이고 명쾌하지 않다. 이에 주의해야 한다.

ex) 
- 펭귄은 새다
- 새는 날 수 있다

이를 이용해 코드르 짠다면? 

```java
public class Bird{
   public void fly() { ... }
   ...
}

public class Penguin extends Bird{
...
}
```
이는 반은 맞고 반은 틀리다.
- 펭귄은 새고, 날 수 없다
- 하지만 코드 상에서는 펭귄은 새이므로 날 수 있다 라고 주장한다.

어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다.
- 새의 정의에 '날 수 있다'는 행동이 포함되지 않는다면 펭귄은 새의 서브타입이 될 수 있다.
- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
- 슈퍼타입과 서브타입의 관계는 is-a 보다 행동 호한성이 더 중요하다.
- is-a라고 표현할 수 있더라도 일단은 상속을 사용할 예비 후보 정도로만 생각하자.

### 행동 호환성
타입은 행동과 관련이 있다.
- 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 해도 행동에 연관성이 없다면 is-a 관계를 사용하면 안된다.
- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.   

행동의 호환 여부를 판단하는 기준 
- 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.
- 클라이언트의 입장에서 모든 새가 날 수 있다고 가정하므로, Penguin이 Bird의 서브타입이 아니다.

상속 관계를 유지하면서 문제를 해결하기 위해 시도할 수 있는 방법
1. Penguin의 fly 메서드를 오버라이딩해서 내부 구현을 비워두는 것

```java
public class Penguin extends Bird {
...
   @Override
   public void fly(){}
}
```
- Penguin은 날 수 없게 된다.
- 하지만 어떤 행동도 수행하지 않기 때문에 클라이언트의 기대 만족 못 시킴
- Penguin과 Bird의 행동이 호한되지 않으므로 올바른 타입 계층이 아님

2. Penguin의 fly 메서드를 오버라이딩한 후 예외를 던지게 하는 것
``` java
public class Penguin extends Bird {
   ...
   @Override
   public void fly() {
        thorw new UnsupportedOperationException();
   }
}
```
- 인자의 타입에 따라 flyBird메서드가 성공하거나 실패하는데 이는 기대하지 않은 값
- 클라이언트의 관점에서 두 객체의 행동이 호환되지 않음

3. flyBird 메서드를 수정해서 인자로 전달된 bird의 타입이 Penguin이 아닐 경우에만 fly 메시지를 전송하도록 하는 것
``` java
public void flyBird(Bird bird){
   if(!(bird instaceof Penguin)){
      bird.fly();
    }
}
```
- Penguin 이외에 날 수 없는 또 다른 새가 추가된다면 코드가 수정되어야 한다.
- 이는 구체적인 클래스에 대한 결합도를 높인다.
- 이는 계방-폐쇄 원칙을 위반한다.

### 클라이언트의 기대에 따라 계층 분리하기
- flyBird 메서드와 협력하는 모든 객체는 fly 메시지에 대해 올바르게 응답할 수 있어야 한다.
- Penguin 인스턴스는 flyBird 메서드에 전달되면 안된다.
- 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 된다.

```java
public class Bird { ... }

public class FlyingBird extends Bird { 
    public void fly() { ... }
}

public class Penguine extends Bird { ... }
```
- flyBird 메서드는 FlyingBird 타입을 이용해 날 수 있는 새만 인자로 전달돼야 한다.
- 날 수 없는 새와 협력하는 메서드가 존재한다면 파라미터의 타입을 Bird로 선언

``` java
public void flyBird(FlyingBird bird){
    bird.fly();
}
```

클라이언트에 따라 인터페이스를 분리해서 해결할 수 있다.
- 인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다.
<img width="696" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/20b2ba3f-6f7a-4ed3-874e-31ce933fc272">

만약 Penguin이 Bird의 코드를 재사용해야한다면?
- 상속보다는 합성을 사용하는 것이 바람직하다
  - 물론 Bird의 퍼블릭 인터페이스를 통해 재사용 가능하다는 전제를 만족
  - Bird의 퍼블릭 인터페이스를 통해 재사용하기 어렵다면 Bird를 약간 수정해야 할 수 있다. 
<img width="644" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/2d31aabd-2316-4085-9447-4299d605b2f2">

인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙 : 인터페이스 분리 원칙

### 서브클래싱과 서브타이핑
- 서브클래싱:
  - 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리킨다.
  - 자식 클래스와 부모 클래스의 행도이 호환되지 않기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
  - 구현 상속 또는 클래스 상속이라고 부른다.

- 서브타이핑:
   - 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가리킨다.
   - 자식 클래스와 부모 클래스의 행동이 호환되기 때문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다.
   - 부모 클래스는 자식 클래스의 슈퍼타입이 되고 자식 클래스는 부모 클래스의 서브타입이 된다.
   - 인터페이스 상속이라고 부르기도 한다.   

- 서브클래싱과 서브타이핑을 나누는 기준은 상속을 사용하는 목적이다.
- 자식 클래스가 부모클래스의 코드를 재사용할 목적으로 상속을 사용 -> 서브클래싱
- 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 목적으로 상속을 사용 -> 서브타이핑
- 서브타이핑 관계가 유지되기 위해서는 서브타입이 슈퍼타입이 하는 모든 행동을 동일하게 할 수 있어야 한다. -> 행동 호환성을 만족시켜야 한다.
- 자식 클래스와 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 대체 가능성을 포함한다.

## 04 리스코프 치환 원칙
- 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.
- 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
- 자식 클래스가 부모 클래스와 행동 호환성을 유지함으로써 부모 클래스를 대체할 수 있도록 구현된 상속 관계만을 서브타이핑이라고 불러야 한다.

### 클라이언트와 대체 가능성
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조
  - Vector의 퍼블릭 인터페이스가 Stack의 퍼블릭 인터페이스에 포함됐기 때문에 리스코프 치환 원칙을 위반
- 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다
- 대체 가능성을 결정하는 것은 결국 클라이언트다.

### is-a 관계 다시 살펴보기
- is-a는 클라이언트 관점에서 is-a일 때만 참이다.
- 객체의 속성이 아니라 객체의 행동이 객체지향에서 중요하다.
- 이름이 아닌 행동이 먼저이다.
- 상속이 서브타이핑을 위해 사용될 경우에만 is-a 관계

### 리스코프 치환 원칙은 유연한 설게의 기반이다.
- 클라이언트의 입장에서 퍼블릭 인터페이스의 행동 방식이 변경되지 않는다면 클라이언트의 코드를 변경하지 않고도 새로운 자식 클래스와 협력할 수 있게 된다.
- LSP는 개방-폐쇄 원칙을 만족하는 설계를 위한 전제 조건이다.
- 자식 클래스가 클라이언트의 관점에서 부모 클래스를 대체할 수 있다면 기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다.

### 타입 계층과 리스코프 치환의 원칙
- 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나
- 자바, C#의 인터페이스, 스칼라의 트레이트, 동적 타입 언어의 덕 타이핑 등의 기법을 사용하면 클래스 사이의 상속을 사용하지 않고 서브타이핑 관계를 구현 가능
- 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용돼야 한다는 것


## 05. 계약에 의한 설계와 서브타이핑
- 계약에 의한 설계: 클라이언트와 서버 사이의 협력을 위한 의무와 이익으로 구성된 계약의 관점에서 표현
- 세 가지 요소: 
   - 사전조건: 클라이언트가 정상적으로 메서드를 실행하기 위해 만족시켜야 함
   - 사후조건: 메서드가 실행된 후에 서버가 클라이언트에게 보장해해야 함
   - 클래스 불변식: 메서드 실행 전과 실행 후에 인스턴스가 만족시켜야 함

- 서브타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 게약을 준수해야 한다.

- 영화 예약 시스템: Movie와 DiscountPolicy의 계약
  - 사전 조건
    - 인자로 전달된 screening이 null이 아니어야 한다.
    - 영화 시작 시간이 아직 지나지 않아야 한다.
  - 사후 조건
    - calculateDiscountAMount메서드의 반환값은 항상 null이 아니어야 한다.

```java
public class Movie {
    ...
    public Money calculateMovieFee(Screening screening) {
        if (screening == null ||
                screening.getStartTime().isBefore(LocalDateTime.now())) {
            throw new InvalidScreeningException();
        }

        return fee.minus(discountPolicy.calculateDiscountAmount(screening));
    }
...
}
```

```java
public abstract class DiscountPolicy {
    ...
    public Money calculateDiscountAmount(Screening screening) {
        checkPrecondition(screening); // 사전조건 체크
        Money amount = Money.ZERO;
        for(DiscountCondition each : conditions) {
            if (each.isSatisfiedBy(screening)) {
                amount = getDiscountAmount(screening);
                checkPostcondition(amount);
                return amount;
            }
        }
        amount = screening.getMovieFee();
        checkPostcondition(amount); // 사후조건 체크
        return amount;
    }
}
```

### 서브타입과 계약
- 계약 관점에서 상속의 큰 문제는 자식이 부모 메서드를 오버라이딩할 수 있다는 것이다.
- 자식 클래스가 부모 클래스의 서브 타입이 되기 위한 조건
  - 서브타입에 더 강력한 사전조건을 정의할 수 없다.
  - 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
  - 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
  - 서브타입에 더 약한 사후조건을 정의할 수 없다.
- 즉 어떤 타입이 슈퍼타입의 서브타입이 되려면
  - 더 강한 사후조건을 정의할 수 있고, 더 약한 사후조건을 정의할 수 없다.
  - 더 약한 사전조건을 정의할 수 있고, 더 강한 사전조건을 정의할 수 없다.
