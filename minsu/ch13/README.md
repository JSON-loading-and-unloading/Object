# 서브클래싱과 서브타이핑
## 01 타입
###  개념 관점의 타입
- 정의
   - 공통의 특징을 공유하는 대상들의 분류
- 타입으로 분류될 때 그 대상을 타입의 인스턴스라고 함
- 타입의 세 가지 요소
  - 심볼: 타입에 이름을 붙인 것
  - 내연 : 타입의 정의로 타이벵 속하는 객체들이 가지는 공통적인 속성이나 행동
  - 외연: 타입에 속하는 객체들의 집합

 ### 프로그래밍 언어 관점의 타입
- 정의
   - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
- 두 가지 목적
  - 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다.
  - 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.

### 객체지향 패러다임 관점의 타입
- 정의
  - 객체의 퍼블릭 인터페이스(객체가 수신할 수 있는 메시지의 집합)을 정의하는 것
  - 동일한 퍼블리 인터페이스를 제공하는 객체들은 동일한 타입으로 본류
- 객체에게 중요한 것
  - 속성이 아닌 행동
  - 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 함   
  -> 동일한 상태이라도 퍼블릭 인터페이스가 다르면 서로 다른 타입   
  -> 반대로 어떤 객체들이 내부 상태가 달라도 동일한 퍼블릭 인터페이스를 공유하면 같은 타입


## 02 타입 계층
### 타입 사이의 포함관계
- 타입은 객체들의 집합이기 때뭉네 다른 타입을 포함할 수 있다.

<img width="452" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/bf1cfefb-b8d3-4d99-a9c9-c5ecbc254f9d">

이를 집합의 관점에서 더 세분화된 타입의 집합을 부분집합으로 포함할 수 있다.

<img width="527" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/79693d8e-3b04-4633-a155-fd60138c3ca5">

- 포함하는 타입은 외연 관점에서는 더 크고 내연 관점에서는 더 일반적이다.
- 포함되는 타입은 외연 관점에서는 더 작고 내연 관점에서는 더 특수하다.


<img width="588" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/4fece4b8-e472-4971-b215-4737794501a8">

- 슈퍼 타입: 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입
- 서브타입: 더 특수한 타입


내연과 외연의 관점에서 일반화와 특수화   
- 일반화:
     - 내연 관점에서 일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정
     - 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋
- 특수화:
    - 내연 관점에서 특수한 타입의 정의는 일반적인 타입의 정의를 좀 더 구체화한 것
    - 외연의 관점에서 특수한 타입에 속한 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 서브셋


슈퍼타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
- 집합이 다른 집합의 모든 멤버를 포함한다.
- 타입 정의가 다른 타입보다 좀 더 일반적이다.

서브타입은 다음과 같은 특징을 가지는 타입을 가리킨다.
- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
- 타입 정의가 다른 타입보다 좀 더 구체적이다.

### 객체지향 프로그래밍과 타입 계층
퍼블릭 인터페이스의 관점에서 슈퍼타입과 서브타입을 다음과 같이 정의할 수 있다.
- 슈퍼타입이란 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
- 서브타입이란 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것
- 더 일반적인 퍼블릭 인터페이스를 가지는 객체들은 더 특수한 퍼블릭 인터페이스를 가지는 객체들의 슈퍼타입이다.
   - 따라서, 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.


## 03 서브클래싱과 서브타이핑
### 언제 상속을 사용해야 하는가?
- 상속의 올바른 용도는 타입 계층을 구현하는 것
- 다음 질문에 모두 "예"라고 답하면 상속을 사용
  - 상속 관계가 is-a 관계를 모델링하는가? (자식 클래스는 부모클래스다가 성립하는가?)
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가? (행동 호환성이 되는가?)

### is-a 관계
- 어떤 타입 S가 다른 타입 T의 일종이라면 s is-a T라고 말할 수 있다.
- 하지만 is-a 관계가 항상 직관적이고 명쾌하지 않다. 이에 주의해야 한다.

ex) 
- 펭귄은 새다
- 새는 날 수 있다

이를 이용해 코드르 짠다면? 

```java
public class Bird{
   public void fly() { ... }
   ...
}

public class Penguin extends Bird{
...
}
```
이는 반은 맞고 반은 틀리다.
- 펭귄은 새고, 날 수 없다
- 하지만 코드 상에서는 펭귄은 새이므로 날 수 있다 라고 주장한다.

어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 잘 보여준다.
- 새의 정의에 '날 수 있다'는 행동이 포함되지 않는다면 펭귄은 새의 서브타입이 될 수 있다.
- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
- 슈퍼타입과 서브타입의 관계는 is-a 보다 행동 호한성이 더 중요하다.
- is-a라고 표현할 수 있더라도 일단은 상속을 사용할 예비 후보 정도로만 생각하자.

### 행동 호환성
타입은 행동과 관련이 있다.
- 타입의 이름 사이에 개념적으로 어떤 연관성이 있다고 해도 행동에 연관성이 없다면 is-a 관계를 사용하면 안된다.
- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.   

행동의 호환 여부를 판단하는 기준 
- 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.
- 클라이언트의 입장에서 모든 새가 날 수 있다고 가정하므로, Penguin이 Bird의 서브타입이 아니다.

상속 관계를 유지하면서 문제를 해결하기 위해 시도할 수 있는 방법
1. Penguin의 fly 메서드를 오버라이딩해서 내부 구현을 비워두는 것

```java
public class Penguin extends Bird {
...
   @Override
   public void fly(){}
}
```
- Penguin은 날 수 없게 된다.
- 하지만 어떤 행동도 수행하지 않기 때문에 클라이언트의 기대 만족 못 시킴
- Penguin과 Bird의 행동이 호한되지 않으므로 올바른 타입 계층이 아님

2. Penguin의 fly 메서드를 오버라이딩한 후 예외를 던지게 하는 것
``` java
public class Penguin extends Bird {
   ...
   @Override
   public void fly() {
        thorw new UnsupportedOperationException();
   }
}
```
- 인자의 타입에 따라 flyBird메서드가 성공하거나 실패하는데 이는 기대하지 않은 값
- 클라이언트의 관점에서 두 객체의 행동이 호환되지 않음

3. flyBird 메서드를 수정해서 인자로 전달된 bird의 타입이 Penguin이 아닐 경우에만 fly 메시지를 전송하도록 하는 것
``` java
public void flyBird(Bird bird){
   if(!(bird instaceof Penguin)){
      bird.fly();
    }
}
```
- Penguin 이외에 날 수 없는 또 다른 새가 추가된다면 코드가 수정되어야 한다.
- 이는 구체적인 클래스에 대한 결합도를 높인다.
- 이는 계방-폐쇄 원칙을 위반한다.

### 클라이언트의 기대에 따라 계층 분리하기
- flyBird 메서드와 협력하는 모든 객체는 fly 메시지에 대해 올바르게 응답할 수 있어야 한다.
- Penguin 인스턴스는 flyBird 메서드에 전달되면 안된다.
- 날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 된다.

```java
public class Bird { ... }

public class FlyingBird extends Bird { 
    public void fly() { ... }
}

public class Penguine extends Bird { ... }
```
- flyBird 메서드는 FlyingBird 타입을 이용해 날 수 있는 새만 인자로 전달돼야 한다.
- 날 수 없는 새와 협력하는 메서드가 존재한다면 파라미터의 타입을 Bird로 선언

``` java
public void flyBird(FlyingBird bird){
    bird.fly();
}
```

클라이언트에 따라 인터페이스를 분리해서 해결할 수 있다.
- 인터페이스는 클라이언트가 기대하는 바에 따라 분리돼야 한다.
<img width="696" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/20b2ba3f-6f7a-4ed3-874e-31ce933fc272">

만약 Penguin이 Bird의 코드를 재사용해야한다면?
- 상속보다는 합성을 사용하는 것이 바람직하다
  - 물론 Bird의 퍼블릭 인터페이스를 통해 재사용 가능하다는 전제를 만족
  - Bird의 퍼블릭 인터페이스를 통해 재사용하기 어렵다면 Bird를 약간 수정해야 할 수 있다. 
<img width="644" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/2d31aabd-2316-4085-9447-4299d605b2f2">

인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙 : 인터페이스 분리 원칙

### 서브클래싱과 서브타이핑
