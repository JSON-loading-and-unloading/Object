# 15 디자인 패턴과 프레임워크
## 01. 디자인 패턴과 설계 재사용
### 소프트웨어 패턴
패턴의 정의    
- 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
- 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
- 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

패턴의 가치   
- 패턴이 지닌 가장 큰 가치는 경험을 통해 축적된 실무 지식을 효과적으로 요약하고 전달할 수 있다는 점
- 패턴은 지식 전달과 커뮤니케이션의 수단으로 활용할 수 있기에 패턴에서 가장 중요한 요소는 패턴의 이름이다.
- 요구사항을 관리하는 방법과 같이 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.
- 패턴은 홀로 존재하지 않으며, 특정 패턴 내에 포함된 컴포넌트와 컴포넌트 간의 관계는 더 작은 패턴에 의해 서술될 수 있다.

### 패턴 분류   
디자인 패턴   
- 특정 정황 내에서 일반적인 설계 문제를 해결하며, 협력하는 컴포넌트들 사이에서 반복적으로 발생하는 구조를 서술한다.
- 중간 규모의 패턴으로 특정한 설계 문제를 해결하는 것을 목적으로 하며, 언어나 패러다임에 독립적이다.

아키텍처 패턴   
- 디자인 패턴의 상위에 있으며, 소프트웨어의 전체적인 구조를 결정하기 위해 사용할 수 있다.
- 미리 정의된 서브시스템들을 제공하고, 각 서브시스템들의 책임을 정의하며, 서브시스템들 사이의 관계를 조직화하는 규칙과 가이드라인을 포함한다.
- 구체적인 소프트웨어 아키텍처를 위한 템플릿을 제공하며, 언어나 패러다임에 독립적이다.

이디엄   
- 디자인 패턴의 하위에 있으며, 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다.
- 주어진 언어의 기능을 사용해 컴포넌트나 컴포넌트 간의 특정 측면을 구현하는 방법을 서술한다.
- 언어에 종속적이므로 특정 언어의 이디엄이 다른 언어에서는 무용지물이 되는 경우도 있다.
ex) C++의 COUNT POINTER : 가상 머신이 참조되지 않는 객체를 자동으로 삭제하는 가비지 컬렉션을 메커니즘을 가진 자바에서는 유용 x


분석 패턴   
- 도메인 내의 개념적인 문제를 해결하는 데 초점을 맞춘다.
- 업무 모델링 시에 발견되는 공통적인 구조를 표현하는 개념들의 집합이다.
- 단 하나의 도메인에 대해서만 적절할 수 도 있고 여러 도메인에 걸쳐 적용할 수도 있다.


### 패턴과 책임-주도 설계
- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다.
- 패턴을 따르면 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다. 
 - 특정한 상황에 적용 가능한 패턴을 잘 알고 있다면 책임 주도 설계의 절차를 하나하나 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.
- 패턴의 구성 요소는 클래스가 아니라 `역할`이다.
  - 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다.
  - 역할은 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시하기 때문에 하나의 클래스가 다수의 역할을 수행할 수 있다.
  - 반대로 다수의 클래스가 동일한 역할을 구현할 수도 있다.

### 캡슐화와 디자인 패턴
대부분의 디자인 패턴은 협력을 일관성 있고 유연하게 만드는 것을 목적으로 한다.   

- 영화 예매 시스템 `Movie`와 `DiscountPolicy` 상속 계층을 합성 관계로 -> ***STRATEGY 패턴***
<img width="648" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/33f7cff3-dca2-4f26-bf15-8a67b39cc68d">

- STRATEGY 패턴
  - 알고리즘의 변경을 캡슐화하기 위함

 - 영화 예매 시스템 `Movie`와 `DiscountPolicy` 상속 관계로 (알고리즘을 캡슐화하기 위해) -> ***TEMPLATE METHOD 패턴***
<img width="616" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/48a9caf9-59cd-4164-a3f8-7aac16327899">

- TEMPLATE METHOD 패턴   
  - 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의하게 함으로써 변경을 캡슐화할 수 있음
  - 합성보다는 결합도가 높아 STRATEGY 패턴처럼 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다.
  - 알고리즘 교체와 같은 요구사항이 없다면 -> 복잡도를 더 낮출 수 있으므로 유용
  - 알고리즘 교체와 같은 요구사항이 있다면 -> STRATEGY 패턴을 쓰는게 더 나음

<br/>

- 핸드폰 과금 시스템 설계 -> ***DECORATOR 패턴***
<img width="732" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/60cb4c36-3d3f-493c-800a-4b05a0420658">

### 패턴은 출발점이다 
- 패턴은 출발점이지 목적지가 아니다.
- 패턴이 제시하는 구조를 맹목적으로 따르는 것은 불필요하게 복잡하고, 난해하며, 유지보수하기 어려운 시스템을 낳는다.

패턴 전문가  vs 패턴 입문자
- 패턴 전문가 : 다양한 실무 경험을 통해 아딴 컨텍스트에서 어떤 패턴을 적용해야 하는지, 어떤 패턴을 적용해서는 안되는지에 대한 감각을 익히고 있다.
- 패턴 입문자:
  -  패턴의 강력함에 매료된 나머지 아무리 사소한 설계라도 패턴을 적용해 보려고 시도한다.
  -  명확한 트레이드오프 없이 패턴을 남용하면 설계가 불필요하게 복잡해지게 된다.
  -  타당한 이유 없이 패턴을 적용하면 패턴에 익숙한 사람들의 경우에는 설계의 의도를 이해하지 못함
  -  패턴을 알지 못하는 사람들은 불필요하게 복잡한 설계를 따라가느라 시간을 낭비하게 된다.


패턴을 적용하려면   
- 항상 설계를 조금 더 단순하고 명확하게 만들 수 있는 방법이 없는지로 정당화해야 한다.
- 함께 작업하는 사람들이 패턴에 익숙한지 여부를 확인하고, 그렇지 않다면 설계에 대한 지식과 더불러 패턴에 대한 지식도 함께 공유하는 것이 필요하다.


## 02. 프레임워크와 코드 재사용
### 코드 재사용 대 설계 재사용
- 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.   
- 개발자들은 부품을 조립해서 제품을 만드는 것처럼 별도의 프로그래밍 없이 기존 컴포넌트를 조립해서 애플리케이션을 구축하는 방법을 추구
  - 애플리케이션과 도메인의 다양성으로 인해 다양한 도메인에 재사용 가능한 컴포넌트라는 개념은 비현실적이다.
- 가장 이상적인 형태의 재사용 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합한 것
   - 설계를 재사용하면서 유사한 코드를 반복적으로 구현하는 문제를 피할 수 있는 방법 : 프레임워크
     - 구조적 측면: 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
     - 사용 측면: 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격
    - 프레임워크 코드를 재사용함으로써 설계 아이디어를 재사용
      - 애플리케이션의 아키텍처를 제공, 문제 해결에 필요한 설계 결정과 이에 필요한 기반 코드를 함께 포함
      - 애플리케이션을 확장할 수 있도록 부분적으로 구현된 추상 클래스와 인터페이스 집합뿐만 아니라 추가적인 작업 없이도 재사용 가능한 다양한 종류의 컴포넌트와 함께 제공

### 상위 정책과 하위 정책으로 패키지 분리하기
- 프레임워크의 핵심은 추상화이다.
  - 추상 클래스와 인터페이스는 일관성 있는 협력을 만드는 핵심 재료다.
  - 협력을 구현하는 코드 안의 의존성은 가급적이면 추상화를 향하도록 해야 한다.
- 객체지향 이전의 구조적인 설계와 같은 전통적인 소프트웨어 개발 방법의 경우 상위 레벨 모듈이 하위 모듈에, 상위 정책이 세부적인 사항에 의존했다.
  - 상위 정책은 상대적으로 안정적이지만 세부 사항은 자주 변경된다.
  - 상위 정책은 세부 사항에 비해 재사용될 가능성이 높다.
  - 상위 정책이 세부 사항보다 더 다양한 상황에서 재사용되어야 하지만, 상위 정책이 세부 사항에 의존하게 되면 상위 정책의 재사용성이 낮아진다.
-> 이 문제를 해결하기 위해 의존성 역전 원칙으로 상위 정책과 세부 사항 모두 추상화에 의존하게 만들어야 한다.
    - 의존성 역전 원칙 관점에서 세부 사항은 `변경`을 의미
- 변하는 부분과 변하지 않는 부분을 별도 패키지로 분리해야 한다.
  - 변하는 것: 구체적인 세부 사항, 변하지 않는 것: 상위 정책에 속하는 역할들의 협력 구조
  - 변하는 것과 변하지 않는 것을 별도의 패키지로 분리
  - <img width="725" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/9f3a2cc5-115b-4719-8165-7cbbfd8c6ab5">
  - 패키지 사이의 의존성 방향: 추상화에만 의존하도록 의존성의 방향을 조정하고 추상화를 경계로 패키지를 분리했기 때문에 세부 사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 한다.
  - 변하는 것과 변하지 않는 것들을 서로 다른 주기로 배포할 수 있도록 `배포 단위`로 분리해야 한다.
  - <img width="652" alt="image" src="https://github.com/JSON-loading-and-unloading/Object-Study/assets/86006389/5e3660f2-cef4-4459-a4f7-9af0b9ed8882">

### 제어 역전 원리
- 객체지향 설계의 재사용성은 개별 크래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다.
- 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다.
  - 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
  - 의존성을 역전시킨 객체지향 구조에서는 반대로 프레임워크가 애플리케이션에 속하는 서브 클래스를 호출한다.
  - 의존성 역전 -> 제어 흐름의 주체 역시 역전
- 제어 역전 원리
  - 프레임워크에선 일반적 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 동작은 비워둔다.
  - 협력을 제어하는 주체가 바로 프레임워크
  - 제어가 우리에게서 프레임워크로 제어가 역전된 것
  - 우리의 코드는 수동적인 존재로, 프레임워크가 우리의 코드를 호출해줄 때까지 기다리고 있는다.
